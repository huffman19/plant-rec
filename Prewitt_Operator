# -*- coding: utf-8 -*-
"""Prewitt_operator.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cnZOmVol51ILOnUVyBKGb2hlxeLhsg6_
"""

import os
import matplotlib.pyplot as plt
import numpy as np
from tkinter import HORIZONTAL
import scipy as sp;
import matplotlib.pyplot as plt;
from scipy import signal
from matplotlib.animation import FuncAnimation
from PIL import Image
from PIL import ImageFilter;
from PIL import ImageOps;
import cv2

from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/drive/MyDrive/images

#load image
rawImage = plt.imread("iris.vip.jpg")
plt.imshow(rawImage)



def x_filter(image):

    #kernel to traverse x
    horizontal_filter = [[-1,0,1],
                        [-1,0,1],
                        [-1,0,1]]    

    height, width = image.shape 
    

    new_image = [[0 for entry in range(height)] for entry in range(width)]

    new_horizontal_image = np.zeros_like(image)
    
 
    for i in range(1, height - 2):
        for j in range(1, width -2):
            local_pixels = image[i-1:i+2, j-1:j+2]
            
            transformed_pixels = horizontal_filter * local_pixels
            #mapping from 0 to 1
            horizontal_score = (transformed_pixels.sum() + 4)/8 #this is mapping the values from 0 to 1,
                                                                #since the maximum possible value is 4 and the
                                                                #minimum is -4.
            new_horizontal_image[i][j] = horizontal_score
    
    return new_horizontal_image

def both_filters_greyscale1(rawImage):

    #kernel to traverse x
    horizontal_filter = [[-1,0,1],
                        [-1,0,1],
                        [-1,0,1]]

    #kernel to traverse y
    vertical_filter =   [[-1,-1,-1],
                        [0,0,0],
                        [1,1,1]]

    height, width = rawImage.shape
    
    new_image = np.zeros_like(rawImage)
    plt.imshow(new_image)
    
    for i in range(1, height - 1):
        for j in range(1, width -1):
            local_pixels = rawImage[i-1:i+2, j-1:j+2]
            
            horizontal_transformed_pixels = horizontal_filter * local_pixels
            horizontal_score = (horizontal_transformed_pixels.sum())    #these values are not plot to 0-1 because otherwise 
                                                                        #the result becomes too dim.
        
            vertical_transformed_pixels = vertical_filter * local_pixels 
            vertical_score = (vertical_transformed_pixels.sum())
            
            edge_score = (vertical_score**2 + horizontal_score**2)**0.5
            new_image[i][j] = edge_score 
    
    return new_image
    




#Preprocessing the image:
original = cv2.imread("iris.vip.jpg")
im_gray = cv2.imread("iris.vip.jpg", cv2.IMREAD_GRAYSCALE)
im_gray = cv2.GaussianBlur(im_gray, (5,5), cv2.BORDER_DEFAULT)



prewitt = both_filters_greyscale1(im_gray)

final_img = x_filter(im_gray)
plt.imshow(final_img,cmap = 'gray')
